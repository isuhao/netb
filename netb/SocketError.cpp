/*
 * Copyright (C) 2017, Maoxu Li. http://maoxuli.com/dev
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "SocketError.hpp"

NETB_BEGIN

namespace SocketError 
{

// 
// Set error object with error message and code, but not classified
// 
void SetError(Error* e, const std::string& msg, int code) 
{
    SET_ERROR(e, msg, code);
}

/*
EBADF   An invalid file descriptor was given in one of the sets.
        (Perhaps a file descriptor that was already closed, or one on
        which an error has occurred.)  However, see BUGS.

EINTR   A signal was caught; see signal(7).

EINVAL  nfds is negative or exceeds the RLIMIT_NOFILE resource limit
        (see getrlimit(2)).

EINVAL  The value contained within timeout is invalid.

ENOMEM  Unable to allocate memory for internal tables.
*/

void Select::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EINVAL: 
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case ENOMEM:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
            SET_ERROR(e, msg, code);
    }
}

/*
Error code for socket() 

EACCES  Permission to create a socket of the specified type and/or
        protocol is denied.

EAFNOSUPPORT
        The implementation does not support the specified address
        family.

EINVAL  Unknown protocol, or protocol family not available.

EINVAL  Invalid flags in type.

EMFILE  The per-process limit on the number of open file descriptors
        has been reached.

ENFILE  The system-wide limit on the total number of open files has
        been reached.

ENOBUFS or ENOMEM
        Insufficient memory is available.  The socket cannot be
        created until sufficient resources are freed.

EPROTONOSUPPORT
        The protocol type or the specified protocol is not supported
        within this domain.

Other errors may be generated by the underlying protocol modules.
*/

void Open::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EAFNOSUPPORT:
        case EINVAL:
        case EPROTONOSUPPORT:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case EACCES:
        case EMFILE:
        case ENFILE:
        case ENOBUFS:
        case ENOMEM:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
            SET_ERROR(e, msg, code);
    }
}

/*
Error code for close():

EBADF  fd isn't a valid open file descriptor.

EINTR  The close() call was interrupted by a signal; see signal(7).

EIO    An I/O error occurred.

See NOTES for a discussion of why close() should not be retried after
an error.
*/

void Close::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case EINTR:
        case EIO:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
            SET_ERROR(e, msg, code);
    }
}

/*
Error code for shutdown()

EBADF   sockfd is not a valid file descriptor.

EINVAL  An invalid value was specified in how (but see BUGS).

ENOTCONN
        The specified socket is not connected.

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.
*/

void Shutdown::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EINVAL:
        case ENOTSOCK:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case ENOTCONN:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
            SET_ERROR(e, msg, code);
    }
}

/*
Error code for bind():

EACCES  The address is protected, and the user is not the superuser.

EADDRINUSE
        The given address is already in use.

EADDRINUSE
        (Internet domain sockets) The port number was specified as
        zero in the socket address structure, but, upon attempting to
        bind to an ephemeral port, it was determined that all port
        numbers in the ephemeral port range are currently in use.  See
        the discussion of /proc/sys/net/ipv4/ip_local_port_range
        ip(7).

EBADF   sockfd is not a valid file descriptor.

EINVAL  The socket is already bound to an address.

EINVAL  addrlen is wrong, or addr is not a valid address for this
        socket's domain.

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.
*/

void Bind::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EACCES: 
        case EADDRINUSE: 
        case EBADF:
        case EINVAL: 
        case ENOTSOCK:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        default:
            SET_ERROR(e, msg, code);
    }
}

/*
Error code for connect():

EACCES, EPERM
        The user tried to connect to a broadcast address without
        having the socket broadcast flag enabled or the connection
        request failed because of a local firewall rule.

EADDRINUSE
        Local address is already in use.

EADDRNOTAVAIL
        (Internet domain sockets) The socket referred to by sockfd had
        not previously been bound to an address and, upon attempting
        to bind it to an ephemeral port, it was determined that all
        port numbers in the ephemeral port range are currently in use.
        See the discussion of /proc/sys/net/ipv4/ip_local_port_range
        in ip(7).

EAFNOSUPPORT
        The passed address didn't have the correct address family in
        its sa_family field.

EAGAIN Insufficient entries in the routing cache.

EALREADY
        The socket is nonblocking and a previous connection attempt
        has not yet been completed.

EBADF  sockfd is not a valid open file descriptor.

ECONNREFUSED
        No-one listening on the remote address.

EFAULT The socket structure address is outside the user's address
        space.

EINPROGRESS
        The socket is nonblocking and the connection cannot be
        completed immediately.  It is possible to select(2) or poll(2)
        for completion by selecting the socket for writing.  After
        select(2) indicates writability, use getsockopt(2) to read the
        SO_ERROR option at level SOL_SOCKET to determine whether
        connect() completed successfully (SO_ERROR is zero) or
        unsuccessfully (SO_ERROR is one of the usual error codes
        listed here, explaining the reason for the failure).

EINTR  The system call was interrupted by a signal that was caught;
        see signal(7).

EISCONN
        The socket is already connected.

ENETUNREACH
        Network is unreachable.

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.

EPROTOTYPE
        The socket type does not support the requested communications
        protocol.  This error can occur, for example, on an attempt to
        connect a UNIX domain datagram socket to a stream socket.

ETIMEDOUT
        Timeout while attempting connection.  The server may be too
        busy to accept new connections.  Note that for IP sockets the
        timeout may be very long when syncookies are enabled on the
        server.


*/

void Connect::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EAFNOSUPPORT: 
        case EALREADY: 
        case EBADF: 
        case EFAULT: 
        case EISCONN: 
        case ENOTSOCK: 
        case EPROTOTYPE: 
        {
            SET_LOGIC_ERROR(e, msg, code);
            return;
        }
        case EACCES: 
        case EPERM: 
        case EADDRINUSE:
        case EADDRNOTAVAIL: 
        case ENETUNREACH: 
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        case EAGAIN: 
        case ECONNREFUSED:
        case EINPROGRESS:
        case EINTR: 
        case ETIMEDOUT: 
        {
            assert(false);
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

void Listen::SetError(Error* e, const std::string& msg, int code)
{

}

void Accept::SetError(Error* e, const std::string& msg, int code)
{
    
}

/*
Error code for send(), sendto(), and sendmsg():

EACCES  (For UNIX domain sockets, which are identified by pathname)
        Write permission is denied on the destination socket file, or
        search permission is denied for one of the directories the
        path prefix.  (See path_resolution(7).)

        (For UDP sockets) An attempt was made to send to a
        network/broadcast address as though it was a unicast address.

EAGAIN or EWOULDBLOCK
        The socket is marked nonblocking and the requested operation
        would block.  POSIX.1-2001 allows either error to be returned
        for this case, and does not require these constants to have
        the same value, so a portable application should check for
        both possibilities.

EAGAIN  (Internet domain datagram sockets) The socket referred to by
        sockfd had not previously been bound to an address and, upon
        attempting to bind it to an ephemeral port, it was determined
        that all port numbers in the ephemeral port range are
        currently in use.  See the discussion of
        /proc/sys/net/ipv4/ip_local_port_range in ip(7).

EBADF   sockfd is not a valid open file descriptor.

ECONNRESET
        Connection reset by peer.

EDESTADDRREQ
        The socket is not connection-mode, and no peer address is set.

EFAULT  An invalid user space address was specified for an argument.

EINTR   A signal occurred before any data was transmitted; see
        signal(7).

EINVAL  Invalid argument passed.

EISCONN
        The connection-mode socket was connected already but a
        recipient was specified.  (Now either this error is returned,
        or the recipient specification is ignored.)

EMSGSIZE
        The socket type requires that message be sent atomically, and
        the size of the message to be sent made this impossible.

ENOBUFS
        The output queue for a network interface was full.  This
        generally indicates that the interface has stopped sending,
        but may be caused by transient congestion.  (Normally, this
        does not occur in Linux.  Packets are just silently dropped
        when a device queue overflows.)

ENOMEM  No memory available.

ENOTCONN
        The socket is not connected, and no target has been given.

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.

EOPNOTSUPP
        Some bit in the flags argument is inappropriate for the socket
        type.

EPIPE   The local end has been shut down on a connection oriented
        socket.  In this case, the process will also receive a SIGPIPE
        unless MSG_NOSIGNAL is set.
*/

void Send::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EACCES:
        case EBADF:
        case EDESTADDRREQ: 
        case EFAULT: 
        case EINVAL: 
        case EISCONN: 
        case EMSGSIZE: 
        case ENOTCONN:
        case ENOTSOCK:
        case EOPNOTSUPP:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case ECONNRESET:
        case ENOBUFS:
        case ENOMEM: 
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        case EAGAIN:
        //case EWOULDBLOCK:
        case EINTR:
        case EPIPE:
        {
            assert(false);
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

/*
Error code for recv(), recvfrom(), and recvmsg():

EAGAIN or EWOULDBLOCK
        The socket is marked nonblocking and the receive operation
        would block, or a receive timeout had been set and the timeout
        expired before data was received.  POSIX.1 allows either error
        to be returned for this case, and does not require these
        constants to have the same value, so a portable application
        should check for both possibilities.

EBADF  The argument sockfd is an invalid file descriptor.

ECONNREFUSED
        A remote host refused to allow the network connection
        (typically because it is not running the requested service).

EFAULT The receive buffer pointer(s) point outside the process's
        address space.

EINTR  The receive was interrupted by delivery of a signal before any
        data were available; see signal(7).

EINVAL Invalid argument passed.

ENOMEM Could not allocate memory for recvmsg().

ENOTCONN
        The socket is associated with a connection-oriented protocol
        and has not been connected (see connect(2) and accept(2)).

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.
*/

void Receive::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EFAULT: 
        case EINVAL:
        case ENOTCONN:
        case ENOTSOCK: 
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case ECONNREFUSED: 
        case ENOMEM:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        case EAGAIN:
        //case EWOULDBLOCK:
        case EINTR: 
        {
            assert(false);
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

/*
Error code for getsockname() and getpeername():

EBADF  The argument sockfd is not a valid file descriptor.

EFAULT The addr argument points to memory not in a valid part of the
        process address space.

EINVAL addrlen is invalid (e.g., is negative).

ENOBUFS
        Insufficient resources were available in the system to perform
        the operation.

ENOTSOCK
        The file descriptor sockfd does not refer to a socket.

ENOTCONN
        The socket is not connected. (for getpeername() only)
*/

void Name::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EFAULT:
        case EINVAL:
        case ENOTSOCK: 
        case ENOTCONN:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case ENOBUFS:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

/*
Error code for fcntl(F_GETFL/F_SETFL):

EACCES or EAGAIN
        Operation is prohibited by locks held by other processes.

EAGAIN  The operation is prohibited because the file has been memory-
        mapped by another process.

EBADF   fd is not an open file descriptor

EFAULT lock is outside your accessible address space.

EINVAL The value specified in cmd is not recognized by this kernel.

ENOLCK Too many segment locks open, lock table is full, or a remote
        locking protocol failed (e.g., locking over NFS).
*/

// Handle fcntl with F_GETFL/F_SETFL errors 

void Control::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EINVAL:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        case EACCES:
        case EAGAIN:
        case EFAULT:
        case ENOLCK:
        {
            SET_RUNTIME_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

/*
// Error code for setsockopt() and getsockopt(): 

EBADF       The argument sockfd is not a valid file descriptor.

EFAULT      The address pointed to by optval is not in a valid part of
            the process address space.  For getsockopt(), this error
            may also be returned if optlen is not in a valid part of
            the process address space.

EINVAL      optlen invalid in setsockopt().  In some cases this error
            can also occur for an invalid value in optval (e.g., for
            the IP_ADD_MEMBERSHIP option described in ip(7)).

ENOPROTOOPT
            The option is unknown at the level indicated.

ENOTSOCK    The file descriptor sockfd does not refer to a socket.
*/

void Option::SetError(Error* e, const std::string& msg, int code)
{
    switch(code)
    {
        case EBADF:
        case EFAULT:
        case EINVAL:
        case ENOPROTOOPT: 
        case ENOTSOCK:
        {
            SET_LOGIC_ERROR(e, msg, code);
            break;
        }
        default:
        {
            SET_ERROR(e, msg, code);
            break;
        }
    }
}

//
// Check if given error code is for system interruption 
// 
bool Interrupted(int code)
{
#ifdef _WIN32
    return code == WSAEINTR;
#else
    return code == EINTR;
#endif
}

//
// Check if given error code is for non-block I/O that would block
// 
bool WouldBlock(int code)
{
#ifdef _WIN32
    return code == WSAEWOULDBLOCK;
#else
    return code == EAGAIN || code == EWOULDBLOCK;
#endif   
}

//
// Check is given error code if for non-block connect that is in progress
//
bool InProgress(int code)
{
#ifdef _WIN32
    return code == WSAEWOULDBLOCK;
#else
    return code == EINPROGRESS;
#endif
}

} // namespace SocketError

NETB_END
